- В функции `build_tree(n)` используется очередь `deque` из пакета `collections`, поскольку элементы добавляются в конец очереди, а затем берутся из начала. Нужен быстрый доступ и к началу, и к концу очереди, поэтому обычный `list` субоптимален. Реальное влияние на производительность крайне низкое, ведь построение происходит один раз, и количество элементов в очереди растет не слишком быстро.
- В функции центрированного обхода `lvr(root)` используется итеративный подход через стек вместо рекурсии. Реальное влияние на производительность крайне низкое, ведь глубина рекурсии будет равна высоте дерева - $O(log(N)) = O(h)$.
- Для чтения номеров узлов из файла используется функция `read_words(f, buffer_size)`. Обычное чтение всей строки через `f.readline().split()` занимает намного больше памяти для самого большого теста - 98.84 МБ по сравнению с 4.64 МБ в итоговом варианте, поскольку строка оказывается крайне большой. Если реализовывать вариант без буфера и читать по одному символу через `f.read(1)`, сильно вырастает время выполнения - 1.427 с. вместо 0.772 с., поскольку происходит огромное количество системных вызовов на чтение. Можно упростить функцию, убрав реализацию для генератора, просто считывая `buffer_size` байт.